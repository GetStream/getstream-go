// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.
package getstream

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// WebhookEvent is implemented by all webhook event types.
type WebhookEvent interface {
	GetEventType() string
}

// Webhook event type constants
const (
	EventTypeWildcard                           = "*"
	EventTypeAppealAccepted                     = "appeal.accepted"
	EventTypeAppealCreated                      = "appeal.created"
	EventTypeAppealRejected                     = "appeal.rejected"
	EventTypeCallAccepted                       = "call.accepted"
	EventTypeCallBlockedUser                    = "call.blocked_user"
	EventTypeCallClosedCaption                  = "call.closed_caption"
	EventTypeCallClosedCaptionsFailed           = "call.closed_captions_failed"
	EventTypeCallClosedCaptionsStarted          = "call.closed_captions_started"
	EventTypeCallClosedCaptionsStopped          = "call.closed_captions_stopped"
	EventTypeCallCreated                        = "call.created"
	EventTypeCallDeleted                        = "call.deleted"
	EventTypeCallDtmf                           = "call.dtmf"
	EventTypeCallEnded                          = "call.ended"
	EventTypeCallFrameRecordingFailed           = "call.frame_recording_failed"
	EventTypeCallFrameRecordingReady            = "call.frame_recording_ready"
	EventTypeCallFrameRecordingStarted          = "call.frame_recording_started"
	EventTypeCallFrameRecordingStopped          = "call.frame_recording_stopped"
	EventTypeCallHLSBroadcastingFailed          = "call.hls_broadcasting_failed"
	EventTypeCallHLSBroadcastingStarted         = "call.hls_broadcasting_started"
	EventTypeCallHLSBroadcastingStopped         = "call.hls_broadcasting_stopped"
	EventTypeCallKickedUser                     = "call.kicked_user"
	EventTypeCallLiveStarted                    = "call.live_started"
	EventTypeCallMemberAdded                    = "call.member_added"
	EventTypeCallMemberRemoved                  = "call.member_removed"
	EventTypeCallMemberUpdated                  = "call.member_updated"
	EventTypeCallMemberUpdatedPermission        = "call.member_updated_permission"
	EventTypeCallMissed                         = "call.missed"
	EventTypeCallModerationBlur                 = "call.moderation_blur"
	EventTypeCallModerationWarning              = "call.moderation_warning"
	EventTypeCallNotification                   = "call.notification"
	EventTypeCallPermissionRequest              = "call.permission_request"
	EventTypeCallPermissionsUpdated             = "call.permissions_updated"
	EventTypeCallReactionNew                    = "call.reaction_new"
	EventTypeCallRecordingFailed                = "call.recording_failed"
	EventTypeCallRecordingReady                 = "call.recording_ready"
	EventTypeCallRecordingStarted               = "call.recording_started"
	EventTypeCallRecordingStopped               = "call.recording_stopped"
	EventTypeCallRejected                       = "call.rejected"
	EventTypeCallRing                           = "call.ring"
	EventTypeCallRTMPBroadcastFailed            = "call.rtmp_broadcast_failed"
	EventTypeCallRTMPBroadcastStarted           = "call.rtmp_broadcast_started"
	EventTypeCallRTMPBroadcastStopped           = "call.rtmp_broadcast_stopped"
	EventTypeCallSessionEnded                   = "call.session_ended"
	EventTypeCallSessionParticipantCountUpdated = "call.session_participant_count_updated"
	EventTypeCallSessionParticipantJoined       = "call.session_participant_joined"
	EventTypeCallSessionParticipantLeft         = "call.session_participant_left"
	EventTypeCallSessionStarted                 = "call.session_started"
	EventTypeCallStatsReportReady               = "call.stats_report_ready"
	EventTypeCallTranscriptionFailed            = "call.transcription_failed"
	EventTypeCallTranscriptionReady             = "call.transcription_ready"
	EventTypeCallTranscriptionStarted           = "call.transcription_started"
	EventTypeCallTranscriptionStopped           = "call.transcription_stopped"
	EventTypeCallUnblockedUser                  = "call.unblocked_user"
	EventTypeCallUpdated                        = "call.updated"
	EventTypeCallUserFeedbackSubmitted          = "call.user_feedback_submitted"
	EventTypeCallUserMuted                      = "call.user_muted"
	EventTypeCampaignCompleted                  = "campaign.completed"
	EventTypeCampaignStarted                    = "campaign.started"
	EventTypeChannelCreated                     = "channel.created"
	EventTypeChannelDeleted                     = "channel.deleted"
	EventTypeChannelFrozen                      = "channel.frozen"
	EventTypeChannelHidden                      = "channel.hidden"
	EventTypeChannelMaxStreakChanged            = "channel.max_streak_changed"
	EventTypeChannelMuted                       = "channel.muted"
	EventTypeChannelTruncated                   = "channel.truncated"
	EventTypeChannelUnfrozen                    = "channel.unfrozen"
	EventTypeChannelUnmuted                     = "channel.unmuted"
	EventTypeChannelUpdated                     = "channel.updated"
	EventTypeChannelVisible                     = "channel.visible"
	EventTypeChannelBatchUpdateCompleted        = "channel_batch_update.completed"
	EventTypeChannelBatchUpdateStarted          = "channel_batch_update.started"
	EventTypeCustom                             = "custom"
	EventTypeExportBulkImageModerationError     = "export.bulk_image_moderation.error"
	EventTypeExportBulkImageModerationSuccess   = "export.bulk_image_moderation.success"
	EventTypeExportChannelsError                = "export.channels.error"
	EventTypeExportChannelsSuccess              = "export.channels.success"
	EventTypeExportModerationLogsError          = "export.moderation_logs.error"
	EventTypeExportModerationLogsSuccess        = "export.moderation_logs.success"
	EventTypeExportUsersError                   = "export.users.error"
	EventTypeExportUsersSuccess                 = "export.users.success"
	EventTypeFeedsActivityAdded                 = "feeds.activity.added"
	EventTypeFeedsActivityDeleted               = "feeds.activity.deleted"
	EventTypeFeedsActivityFeedback              = "feeds.activity.feedback"
	EventTypeFeedsActivityMarked                = "feeds.activity.marked"
	EventTypeFeedsActivityPinned                = "feeds.activity.pinned"
	EventTypeFeedsActivityReactionAdded         = "feeds.activity.reaction.added"
	EventTypeFeedsActivityReactionDeleted       = "feeds.activity.reaction.deleted"
	EventTypeFeedsActivityReactionUpdated       = "feeds.activity.reaction.updated"
	EventTypeFeedsActivityRemovedFromFeed       = "feeds.activity.removed_from_feed"
	EventTypeFeedsActivityRestored              = "feeds.activity.restored"
	EventTypeFeedsActivityUnpinned              = "feeds.activity.unpinned"
	EventTypeFeedsActivityUpdated               = "feeds.activity.updated"
	EventTypeFeedsBookmarkAdded                 = "feeds.bookmark.added"
	EventTypeFeedsBookmarkDeleted               = "feeds.bookmark.deleted"
	EventTypeFeedsBookmarkUpdated               = "feeds.bookmark.updated"
	EventTypeFeedsBookmarkFolderDeleted         = "feeds.bookmark_folder.deleted"
	EventTypeFeedsBookmarkFolderUpdated         = "feeds.bookmark_folder.updated"
	EventTypeFeedsCommentAdded                  = "feeds.comment.added"
	EventTypeFeedsCommentDeleted                = "feeds.comment.deleted"
	EventTypeFeedsCommentReactionAdded          = "feeds.comment.reaction.added"
	EventTypeFeedsCommentReactionDeleted        = "feeds.comment.reaction.deleted"
	EventTypeFeedsCommentReactionUpdated        = "feeds.comment.reaction.updated"
	EventTypeFeedsCommentUpdated                = "feeds.comment.updated"
	EventTypeFeedsFeedCreated                   = "feeds.feed.created"
	EventTypeFeedsFeedDeleted                   = "feeds.feed.deleted"
	EventTypeFeedsFeedUpdated                   = "feeds.feed.updated"
	EventTypeFeedsFeedGroupChanged              = "feeds.feed_group.changed"
	EventTypeFeedsFeedGroupDeleted              = "feeds.feed_group.deleted"
	EventTypeFeedsFeedMemberAdded               = "feeds.feed_member.added"
	EventTypeFeedsFeedMemberRemoved             = "feeds.feed_member.removed"
	EventTypeFeedsFeedMemberUpdated             = "feeds.feed_member.updated"
	EventTypeFeedsFollowCreated                 = "feeds.follow.created"
	EventTypeFeedsFollowDeleted                 = "feeds.follow.deleted"
	EventTypeFeedsFollowUpdated                 = "feeds.follow.updated"
	EventTypeFeedsNotificationFeedUpdated       = "feeds.notification_feed.updated"
	EventTypeFeedsStoriesFeedUpdated            = "feeds.stories_feed.updated"
	EventTypeFlagUpdated                        = "flag.updated"
	EventTypeIngressError                       = "ingress.error"
	EventTypeIngressStarted                     = "ingress.started"
	EventTypeIngressStopped                     = "ingress.stopped"
	EventTypeMemberAdded                        = "member.added"
	EventTypeMemberRemoved                      = "member.removed"
	EventTypeMemberUpdated                      = "member.updated"
	EventTypeMessageDeleted                     = "message.deleted"
	EventTypeMessageFlagged                     = "message.flagged"
	EventTypeMessageNew                         = "message.new"
	EventTypeMessagePending                     = "message.pending"
	EventTypeMessageRead                        = "message.read"
	EventTypeMessageUnblocked                   = "message.unblocked"
	EventTypeMessageUndeleted                   = "message.undeleted"
	EventTypeMessageUpdated                     = "message.updated"
	EventTypeModerationCustomAction             = "moderation.custom_action"
	EventTypeModerationFlagged                  = "moderation.flagged"
	EventTypeModerationMarkReviewed             = "moderation.mark_reviewed"
	EventTypeModerationCheckCompleted           = "moderation_check.completed"
	EventTypeModerationRuleTriggered            = "moderation_rule.triggered"
	EventTypeNotificationMarkUnread             = "notification.mark_unread"
	EventTypeNotificationReminderDue            = "notification.reminder_due"
	EventTypeNotificationThreadMessageNew       = "notification.thread_message_new"
	EventTypeReactionDeleted                    = "reaction.deleted"
	EventTypeReactionNew                        = "reaction.new"
	EventTypeReactionUpdated                    = "reaction.updated"
	EventTypeReminderCreated                    = "reminder.created"
	EventTypeReminderDeleted                    = "reminder.deleted"
	EventTypeReminderUpdated                    = "reminder.updated"
	EventTypeReviewQueueItemNew                 = "review_queue_item.new"
	EventTypeReviewQueueItemUpdated             = "review_queue_item.updated"
	EventTypeThreadUpdated                      = "thread.updated"
	EventTypeUserBanned                         = "user.banned"
	EventTypeUserDeactivated                    = "user.deactivated"
	EventTypeUserDeleted                        = "user.deleted"
	EventTypeUserFlagged                        = "user.flagged"
	EventTypeUserMessagesDeleted                = "user.messages.deleted"
	EventTypeUserMuted                          = "user.muted"
	EventTypeUserReactivated                    = "user.reactivated"
	EventTypeUserUnbanned                       = "user.unbanned"
	EventTypeUserUnmuted                        = "user.unmuted"
	EventTypeUserUnreadMessageReminder          = "user.unread_message_reminder"
	EventTypeUserUpdated                        = "user.updated"
)

// GetEventType extracts the event type from a raw webhook payload.
// This is useful for routing webhooks before full deserialization.
//
// Example:
//
//	eventType := getstream.GetEventType(body)
//	switch eventType {
//	case "message.new":
//	    // handle message.new
//	}
func GetEventType(rawEvent []byte) string {
	var result struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(rawEvent, &result); err != nil {
		return ""
	}
	return result.Type
}

// ParseWebhookEvent deserializes a raw webhook payload into a typed event.
// It uses the "type" field to determine which event struct to deserialize into.
//
// Returns WebhookEvent - the concrete event type (e.g., *MessageNewEvent, *ChannelCreatedEvent).
// All webhook events implement the WebhookEvent interface with a GetEventType() method.
//
// Returns an error if the event type is unknown or if deserialization fails.
//
// Example usage:
//
//	func webhookHandler(w http.ResponseWriter, r *http.Request) {
//	    body, _ := io.ReadAll(r.Body)
//	    signature := r.Header.Get("X-Signature")
//	    secret := os.Getenv("STREAM_WEBHOOK_SECRET")
//
//	    if !getstream.VerifyWebhookSignature(body, signature, secret) {
//	        http.Error(w, "Invalid signature", http.StatusForbidden)
//	        return
//	    }
//
//	    event, err := getstream.ParseWebhookEvent(body)
//	    if err != nil {
//	        http.Error(w, err.Error(), http.StatusBadRequest)
//	        return
//	    }
//
//	    switch e := event.(type) {
//	    case *getstream.MessageNewEvent:
//	        fmt.Printf("New message: %s\n", e.Message.Text)
//	    case *getstream.ChannelCreatedEvent:
//	        fmt.Printf("Channel created: %s\n", e.Channel.Cid)
//	    default:
//	        fmt.Printf("Unknown event type: %s\n", e.GetEventType())
//	    }
//	    w.WriteHeader(200)
//	}
func ParseWebhookEvent(rawEvent []byte) (WebhookEvent, error) {
	eventType := GetEventType(rawEvent)
	if eventType == "" {
		return nil, fmt.Errorf("missing 'type' field in webhook payload")
	}
	var event WebhookEvent
	switch eventType {

	case "*":
		event = new(CustomEvent)
	case "appeal.accepted":
		event = new(AppealAcceptedEvent)
	case "appeal.created":
		event = new(AppealCreatedEvent)
	case "appeal.rejected":
		event = new(AppealRejectedEvent)
	case "call.accepted":
		event = new(CallAcceptedEvent)
	case "call.blocked_user":
		event = new(BlockedUserEvent)
	case "call.closed_caption":
		event = new(ClosedCaptionEvent)
	case "call.closed_captions_failed":
		event = new(CallClosedCaptionsFailedEvent)
	case "call.closed_captions_started":
		event = new(CallClosedCaptionsStartedEvent)
	case "call.closed_captions_stopped":
		event = new(CallClosedCaptionsStoppedEvent)
	case "call.created":
		event = new(CallCreatedEvent)
	case "call.deleted":
		event = new(CallDeletedEvent)
	case "call.dtmf":
		event = new(CallDTMFEvent)
	case "call.ended":
		event = new(CallEndedEvent)
	case "call.frame_recording_failed":
		event = new(CallFrameRecordingFailedEvent)
	case "call.frame_recording_ready":
		event = new(CallFrameRecordingFrameReadyEvent)
	case "call.frame_recording_started":
		event = new(CallFrameRecordingStartedEvent)
	case "call.frame_recording_stopped":
		event = new(CallFrameRecordingStoppedEvent)
	case "call.hls_broadcasting_failed":
		event = new(CallHLSBroadcastingFailedEvent)
	case "call.hls_broadcasting_started":
		event = new(CallHLSBroadcastingStartedEvent)
	case "call.hls_broadcasting_stopped":
		event = new(CallHLSBroadcastingStoppedEvent)
	case "call.kicked_user":
		event = new(KickedUserEvent)
	case "call.live_started":
		event = new(CallLiveStartedEvent)
	case "call.member_added":
		event = new(CallMemberAddedEvent)
	case "call.member_removed":
		event = new(CallMemberRemovedEvent)
	case "call.member_updated":
		event = new(CallMemberUpdatedEvent)
	case "call.member_updated_permission":
		event = new(CallMemberUpdatedPermissionEvent)
	case "call.missed":
		event = new(CallMissedEvent)
	case "call.moderation_blur":
		event = new(CallModerationBlurEvent)
	case "call.moderation_warning":
		event = new(CallModerationWarningEvent)
	case "call.notification":
		event = new(CallNotificationEvent)
	case "call.permission_request":
		event = new(PermissionRequestEvent)
	case "call.permissions_updated":
		event = new(UpdatedCallPermissionsEvent)
	case "call.reaction_new":
		event = new(CallReactionEvent)
	case "call.recording_failed":
		event = new(CallRecordingFailedEvent)
	case "call.recording_ready":
		event = new(CallRecordingReadyEvent)
	case "call.recording_started":
		event = new(CallRecordingStartedEvent)
	case "call.recording_stopped":
		event = new(CallRecordingStoppedEvent)
	case "call.rejected":
		event = new(CallRejectedEvent)
	case "call.ring":
		event = new(CallRingEvent)
	case "call.rtmp_broadcast_failed":
		event = new(CallRtmpBroadcastFailedEvent)
	case "call.rtmp_broadcast_started":
		event = new(CallRtmpBroadcastStartedEvent)
	case "call.rtmp_broadcast_stopped":
		event = new(CallRtmpBroadcastStoppedEvent)
	case "call.session_ended":
		event = new(CallSessionEndedEvent)
	case "call.session_participant_count_updated":
		event = new(CallSessionParticipantCountsUpdatedEvent)
	case "call.session_participant_joined":
		event = new(CallSessionParticipantJoinedEvent)
	case "call.session_participant_left":
		event = new(CallSessionParticipantLeftEvent)
	case "call.session_started":
		event = new(CallSessionStartedEvent)
	case "call.stats_report_ready":
		event = new(CallStatsReportReadyEvent)
	case "call.transcription_failed":
		event = new(CallTranscriptionFailedEvent)
	case "call.transcription_ready":
		event = new(CallTranscriptionReadyEvent)
	case "call.transcription_started":
		event = new(CallTranscriptionStartedEvent)
	case "call.transcription_stopped":
		event = new(CallTranscriptionStoppedEvent)
	case "call.unblocked_user":
		event = new(UnblockedUserEvent)
	case "call.updated":
		event = new(CallUpdatedEvent)
	case "call.user_feedback_submitted":
		event = new(CallUserFeedbackSubmittedEvent)
	case "call.user_muted":
		event = new(CallUserMutedEvent)
	case "campaign.completed":
		event = new(CampaignCompletedEvent)
	case "campaign.started":
		event = new(CampaignStartedEvent)
	case "channel.created":
		event = new(ChannelCreatedEvent)
	case "channel.deleted":
		event = new(ChannelDeletedEvent)
	case "channel.frozen":
		event = new(ChannelFrozenEvent)
	case "channel.hidden":
		event = new(ChannelHiddenEvent)
	case "channel.max_streak_changed":
		event = new(MaxStreakChangedEvent)
	case "channel.muted":
		event = new(ChannelMutedEvent)
	case "channel.truncated":
		event = new(ChannelTruncatedEvent)
	case "channel.unfrozen":
		event = new(ChannelUnFrozenEvent)
	case "channel.unmuted":
		event = new(ChannelUnmutedEvent)
	case "channel.updated":
		event = new(ChannelUpdatedEvent)
	case "channel.visible":
		event = new(ChannelVisibleEvent)
	case "channel_batch_update.completed":
		event = new(ChannelBatchCompletedEvent)
	case "channel_batch_update.started":
		event = new(ChannelBatchStartedEvent)
	case "custom":
		event = new(CustomVideoEvent)
	case "export.bulk_image_moderation.error":
		event = new(AsyncExportErrorEvent)
	case "export.bulk_image_moderation.success":
		event = new(AsyncBulkImageModerationEvent)
	case "export.channels.error":
		event = new(AsyncExportErrorEvent)
	case "export.channels.success":
		event = new(AsyncExportChannelsEvent)
	case "export.moderation_logs.error":
		event = new(AsyncExportErrorEvent)
	case "export.moderation_logs.success":
		event = new(AsyncExportModerationLogsEvent)
	case "export.users.error":
		event = new(AsyncExportErrorEvent)
	case "export.users.success":
		event = new(AsyncExportUsersEvent)
	case "feeds.activity.added":
		event = new(ActivityAddedEvent)
	case "feeds.activity.deleted":
		event = new(ActivityDeletedEvent)
	case "feeds.activity.feedback":
		event = new(ActivityFeedbackEvent)
	case "feeds.activity.marked":
		event = new(ActivityMarkEvent)
	case "feeds.activity.pinned":
		event = new(ActivityPinnedEvent)
	case "feeds.activity.reaction.added":
		event = new(ActivityReactionAddedEvent)
	case "feeds.activity.reaction.deleted":
		event = new(ActivityReactionDeletedEvent)
	case "feeds.activity.reaction.updated":
		event = new(ActivityReactionUpdatedEvent)
	case "feeds.activity.removed_from_feed":
		event = new(ActivityRemovedFromFeedEvent)
	case "feeds.activity.restored":
		event = new(ActivityRestoredEvent)
	case "feeds.activity.unpinned":
		event = new(ActivityUnpinnedEvent)
	case "feeds.activity.updated":
		event = new(ActivityUpdatedEvent)
	case "feeds.bookmark.added":
		event = new(BookmarkAddedEvent)
	case "feeds.bookmark.deleted":
		event = new(BookmarkDeletedEvent)
	case "feeds.bookmark.updated":
		event = new(BookmarkUpdatedEvent)
	case "feeds.bookmark_folder.deleted":
		event = new(BookmarkFolderDeletedEvent)
	case "feeds.bookmark_folder.updated":
		event = new(BookmarkFolderUpdatedEvent)
	case "feeds.comment.added":
		event = new(CommentAddedEvent)
	case "feeds.comment.deleted":
		event = new(CommentDeletedEvent)
	case "feeds.comment.reaction.added":
		event = new(CommentReactionAddedEvent)
	case "feeds.comment.reaction.deleted":
		event = new(CommentReactionDeletedEvent)
	case "feeds.comment.reaction.updated":
		event = new(CommentReactionUpdatedEvent)
	case "feeds.comment.updated":
		event = new(CommentUpdatedEvent)
	case "feeds.feed.created":
		event = new(FeedCreatedEvent)
	case "feeds.feed.deleted":
		event = new(FeedDeletedEvent)
	case "feeds.feed.updated":
		event = new(FeedUpdatedEvent)
	case "feeds.feed_group.changed":
		event = new(FeedGroupChangedEvent)
	case "feeds.feed_group.deleted":
		event = new(FeedGroupDeletedEvent)
	case "feeds.feed_member.added":
		event = new(FeedMemberAddedEvent)
	case "feeds.feed_member.removed":
		event = new(FeedMemberRemovedEvent)
	case "feeds.feed_member.updated":
		event = new(FeedMemberUpdatedEvent)
	case "feeds.follow.created":
		event = new(FollowCreatedEvent)
	case "feeds.follow.deleted":
		event = new(FollowDeletedEvent)
	case "feeds.follow.updated":
		event = new(FollowUpdatedEvent)
	case "feeds.notification_feed.updated":
		event = new(NotificationFeedUpdatedEvent)
	case "feeds.stories_feed.updated":
		event = new(StoriesFeedUpdatedEvent)
	case "flag.updated":
		event = new(FlagUpdatedEvent)
	case "ingress.error":
		event = new(IngressErrorEvent)
	case "ingress.started":
		event = new(IngressStartedEvent)
	case "ingress.stopped":
		event = new(IngressStoppedEvent)
	case "member.added":
		event = new(MemberAddedEvent)
	case "member.removed":
		event = new(MemberRemovedEvent)
	case "member.updated":
		event = new(MemberUpdatedEvent)
	case "message.deleted":
		event = new(MessageDeletedEvent)
	case "message.flagged":
		event = new(MessageFlaggedEvent)
	case "message.new":
		event = new(MessageNewEvent)
	case "message.pending":
		event = new(PendingMessageEvent)
	case "message.read":
		event = new(MessageReadEvent)
	case "message.unblocked":
		event = new(MessageUnblockedEvent)
	case "message.undeleted":
		event = new(MessageUndeletedEvent)
	case "message.updated":
		event = new(MessageUpdatedEvent)
	case "moderation.custom_action":
		event = new(ModerationCustomActionEvent)
	case "moderation.flagged":
		event = new(ModerationFlaggedEvent)
	case "moderation.mark_reviewed":
		event = new(ModerationMarkReviewedEvent)
	case "moderation_check.completed":
		event = new(ModerationCheckCompletedEvent)
	case "moderation_rule.triggered":
		event = new(ModerationRulesTriggeredEvent)
	case "notification.mark_unread":
		event = new(NotificationMarkUnreadEvent)
	case "notification.reminder_due":
		event = new(ReminderNotificationEvent)
	case "notification.thread_message_new":
		event = new(NotificationThreadMessageNewEvent)
	case "reaction.deleted":
		event = new(ReactionDeletedEvent)
	case "reaction.new":
		event = new(ReactionNewEvent)
	case "reaction.updated":
		event = new(ReactionUpdatedEvent)
	case "reminder.created":
		event = new(ReminderCreatedEvent)
	case "reminder.deleted":
		event = new(ReminderDeletedEvent)
	case "reminder.updated":
		event = new(ReminderUpdatedEvent)
	case "review_queue_item.new":
		event = new(ReviewQueueItemNewEvent)
	case "review_queue_item.updated":
		event = new(ReviewQueueItemUpdatedEvent)
	case "thread.updated":
		event = new(ThreadUpdatedEvent)
	case "user.banned":
		event = new(UserBannedEvent)
	case "user.deactivated":
		event = new(UserDeactivatedEvent)
	case "user.deleted":
		event = new(UserDeletedEvent)
	case "user.flagged":
		event = new(UserFlaggedEvent)
	case "user.messages.deleted":
		event = new(UserMessagesDeletedEvent)
	case "user.muted":
		event = new(UserMutedEvent)
	case "user.reactivated":
		event = new(UserReactivatedEvent)
	case "user.unbanned":
		event = new(UserUnbannedEvent)
	case "user.unmuted":
		event = new(UserUnmutedEvent)
	case "user.unread_message_reminder":
		event = new(UserUnreadReminderEvent)
	case "user.updated":
		event = new(UserUpdatedEvent)
	default:
		return nil, fmt.Errorf("unknown webhook event type: %s", eventType)
	}
	if err := json.Unmarshal(rawEvent, event); err != nil {
		return nil, fmt.Errorf("failed to unmarshal webhook event: %w", err)
	}
	return event, nil
}

// VerifyWebhookSignature verifies the HMAC-SHA256 signature of a webhook payload.
// This function should be used to verify that webhook requests are authentically from Stream.
//
// Parameters:
//   - body: The raw request body bytes
//   - signature: The signature from the X-Signature header
//   - secret: Your webhook secret (found in the Stream Dashboard)
//
// Returns true if the signature is valid, false otherwise.
//
// Example usage:
//
//	func webhookHandler(w http.ResponseWriter, r *http.Request) {
//	    body, _ := io.ReadAll(r.Body)
//	    signature := r.Header.Get("X-Signature")
//	    secret := os.Getenv("STREAM_WEBHOOK_SECRET")
//
//	    if !getstream.VerifyWebhookSignature(body, signature, secret) {
//	        http.Error(w, "Invalid signature", http.StatusForbidden)
//	        return
//	    }
//	    // Process webhook...
//	}
func VerifyWebhookSignature(body []byte, signature string, secret string) bool {
	h := hmac.New(sha256.New, []byte(secret))
	h.Write(body)
	expected := hex.EncodeToString(h.Sum(nil))
	return hmac.Equal([]byte(signature), []byte(expected))
}

// VerifyAndParseWebhook verifies the webhook signature and parses the event.
// The request body is restored after reading to keep it available for downstream handlers.
//
// Example:
//
//	func webhookHandler(w http.ResponseWriter, r *http.Request) {
//	    event, err := getstream.VerifyAndParseWebhook(r, secret)
//	    if err != nil {
//	        http.Error(w, err.Error(), http.StatusBadRequest)
//	        return
//	    }
//	    // Handle event...
//	    w.WriteHeader(http.StatusOK)
//	}
func VerifyAndParseWebhook(r *http.Request, secret string) (WebhookEvent, error) {
	body, err := io.ReadAll(r.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body: %w", err)
	}
	r.Body.Close()
	r.Body = io.NopCloser(bytes.NewBuffer(body))

	signature := r.Header.Get("X-Signature")
	if signature == "" {
		return nil, fmt.Errorf("missing X-Signature header")
	}

	if !VerifyWebhookSignature(body, signature, secret) {
		return nil, fmt.Errorf("invalid signature")
	}

	return ParseWebhookEvent(body)
}

// WebhookMiddleware creates middleware that verifies signatures and parses webhook events.
// The parsed event is available in your handler via r.Context().
//
// Example:
//
//	mux := http.NewServeMux()
//	mux.HandleFunc("/webhook", func(w http.ResponseWriter, r *http.Request) {
//	    event := r.Context().Value(getstream.WebhookEventKey)
//	    switch e := event.(type) {
//	    case *getstream.MessageNewEvent:
//	        // Handle event...
//	    }
//	    w.WriteHeader(http.StatusOK)
//	})
//	http.Handle("/webhook", getstream.WebhookMiddleware(secret)(mux))
func WebhookMiddleware(secret string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != "POST" {
				http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
				return
			}

			event, err := VerifyAndParseWebhook(r, secret)
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}

			ctx := context.WithValue(r.Context(), WebhookEventKey, event)
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

type webhookEventKeyType struct{}

// WebhookEventKey is the context key for accessing the parsed webhook event.
// The underlying type webhookEventKeyType is unexported to prevent collisions.
var WebhookEventKey = webhookEventKeyType{}
